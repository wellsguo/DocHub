### 控制反转 (IoC)

对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。如，Spring容器。

### 依赖注入

被动的接收对象，在类 A 的实例创建过程中即创建了依赖的B对象，通过类型或名称来判断将不同的对象注入到不同的属性中。

### 依赖注入常见的实现

1. 基于接口。实现特定接口以供外部容器注入所依赖类型的对象。
2. 基于 set 方法。实现特定属性的public set方法，来让外部容器调用传入所依赖类型的对象。
3. 基于构造函数。实现特定参数的构造函数，在新建对象时传入所依赖类型的对象。
4. 基于注解。基于Java的注解功能，在私有变量前加“@Autowired”等注解，不需要显式的定义以上三种代码，便可以让外部容器传入对应的对象。该方案相当于定义了public的set方法，但是因为没有真正的set方法，从而不会为了实现依赖注入导致暴露了不该暴露的接口（因为set方法只想让容器访问来注入而并不希望其他依赖此类的对象访问）。
5. 依赖查找：主动索取响应名称的对象，获得依赖对象的时间也可以在代码中自由控制。

### 依赖反转原则：

1. 高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。
2. 抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。

应用依赖反转原则同样被认为是应用了适配器模式，例如：高层的类定义了它自己的适配器接口（高层类所依赖的抽象接口）。被适配的对象同样依赖于适配器接口的抽象（这是当然的，因为它实现了这个接口），同时它的实现则可以使用它自身所在低层模块的代码。通过这种方式，高层组件则不依赖于低层组件，因为它（高层组件）仅间接的通过调用配置器接口多态方法的方式使用了低层组件通过适配器接口，在这些多态方法则是由被适配对象以及它的低层模块所实现的。

### Android 依赖注入目的

1. 减少样板代码
2. 提高重用性，测试性，可维护性.

##### Android依赖注入库

- RoboGuice   
- Android Annotations   
- Dragger **（推荐）** 
- ButterKnife  **（推荐）** 
- Transfuse  

#### 1. ButterKnife
```java
@Bind(R.id.title) TextView title;
```
@bind 和 viewId 相结合能够自动联系到 layout 的 view（使用场景 activity 和 fragment 、viewholder 等需要与 view 结合的地方都可以使用）。
在使用@bind结合view之后，需要调用```ButterKnife.bind(this)```或者```ButterKnife.bind(this,view)```方式真正实现依赖注入，则可以代替 findViewByID。

注意：在 Fragment 生命周期中，onDestoryView 也需要 ```Butterknife.unbind(this)```

#### 2. Dagger

依赖注入框架，Dagger两种主要方法:

- 第一，@Inject 写到对象类的构造函数上面，要用的时候直接注入对象，避免 new 对象，造成强耦合。且可以加上注释 @Singleton 形成单例。
- 第二，以 @module 和 @provides 为基础，可以任意注入对象，且可以带参操作。Module 里面若是要有其他 Module，要在 includes 里写好，@Module 除了 include，还有 injects 参数指定注入位置，library 指定是否需要外部库，complete 是否是完整 module（含有外部 module 依赖则不完整）。

最后在注入目的地，通过 ObjectGraph（对象图表）形成依赖关系，具体操作方式，ObjectGraph 对象，并调用方法 create(Module).inject (注入对象);则可以直接用 @inject 注入目标对象类里。

#### 3. Dagger和 butterknife 区别

- Bufferknife 目的为注入到 view，所以能够在非 activity 里面注入，也能注入到 inflate 的 views 里面。
- Dagger能够注入到任何你想要的对象，只要其在 module 类中。或者它是构造器。但是缺少对方法和字段的注入支持。
- Bufferknife 只是避免样板代码，findViewById，仅此而已，所以不能算是一个真正的注入。只是一个 view 的代言。

>对于 Dagger 我们可以把它当做应用中的一个模块， 负责为其它模块提供实例并且注入依赖关系。那是它的基本职责。模块的创建位于我们应用中的一个点上，这样我们可以拥有完全的控制权。Dagger Leiva 说，特别适合用在低端设备上，因为它没有采取反射而使用了预编译技术，因为基于反射的 DI 非常占用资源和耗时。Dagger 或许不是最理想的依赖注入框架，但 Leiva 认为，它是最高效的。
