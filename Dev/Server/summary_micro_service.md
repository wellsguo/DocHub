# 微服务
[1] [微服务架构设计](https://www.cnblogs.com/wintersun/p/6219259.html)

#### 释义

（ microservice style ）简而言之，微服务架构是一种将单应用程序作为一套小型服务开发的方法，每种应用程序都在其自己的进程中运行，并与轻量级机制（ 通常是 HTTP 资源的 API ）进行通信。这些服务是围绕业务功能构建的，可以通过全自动部署机制进行独立部署。这些服务的集中化管理已经是最少的，它们可以用不同的编程语言编写，并使用不同的数据存储技术。

![微服务 vs 一体式](https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=1381117690,1102644284&fm=173&app=25&f=JPEG?w=640&h=392&s=4C86ED1B1B8548CA445141C00200E031)

![什么时候应该使用微服务](https://images2015.cnblogs.com/blog/15172/201612/15172-20161225120450401-828812990.png)

#### 通过服务（Sevice）实现组件化

只要我们参与过软件行业，这就存在一种期盼：通过将组件整合在一起来构建系统，这与我们在现实世界中看待事物的方式非常相似。在过去的几十年中，我们已经见证了大部分语言平台中常见库的大量摘要所取得的巨大进步。在谈及组件时，我们遇到了对组件构成定义的难题。我们的定义是，**组件**是可独立更换和升级的软件单元。

微服务架构一样会用到各种库，但这种架构会把软件给拆分成各种不同的服务来实现组件化。这里我们定义两个重要的概念：**库(library) **指的是链接到程序的组件，通过本地函数调用来使用库提供的功能；而**服务 (service) **是进程外的组件，通过<u>网络服务请求 (web service request) </u>或者<u>远程函数调用</u>之类的机制来使用里面的功能。注意这和很多面向对象程序里服务对象的机制是不同的 [3]。

之所以在组件化的软件里用服务，而不是库，一个主要原因就是<u>各个服务是可以独立部署</u>的。比如说，如果在同一个软件 [4] 里用了多个库，那么就算只是修改了其中一个，都会导致整个软件要被重新部署；相反，如果用的是服务，那只需要重新部署修改过的就可以。然而，有个问题是，当修改服务时，可能会把服务接口也给修改了，这样一来，服务的调用者和开发者就得自己私下协调了。好的微服务架构，就应该尽量避免这种问题；非要修改服务契约的话，也得循序渐进，让调用者有迹可循，不用私下协调。

使用服务作为组件的另一个后果是更显式的组件接口。大多数语言都没有很好的机制来定义显式发布的接口。通常，只有文档和规程可以防止客户机破坏组件的封装，从而导致组件之间的紧密耦合。通过使用显式的远程调用机制，服务可以更容易地避免这种情况。使用这样的服务确实有缺点。**远程调用比进程内调用更昂贵**，因此远程api需要粗粒度，这通常更难以使用。如果您需要更改组件之间的职责分配，那么当您跨越流程边界时，这种行为的移动就更加困难了。

我们可以观察到服务映射到运行时进程，但这只是第一次近似。服务可能包括多个进程，这些进程将始终会一起开发和部署，例如应用进程和服务所用到的数据库。

#### 服务间的通信

一般同步调用比较简单，一致性强，但是容易出调用问题，性能体验上也会差些，特别是调用层次多的时候。RESTful 和 RPC 的比较也是一个很有意思的话题。一般 REST 基于 HTTP，更容易实现，更容易被接受，服务端实现技术也更灵活些，各个语言都能支持，同时能跨客户端，对客户端没有特殊的要求，只要封装了 HTTP 的 SDK 就能调用，所以相对使用的广一些。RPC 也有自己的优点，传输协议更高效，安全更可控，特别在一个公司内部，如果有统一个 的开发规范和统一的服务框架时，他的开发效率优势更明显些。就看各自的技术积累实际条件，自己的选择了。而异步消息的方式在分布式系统中有特别广泛的应用，他既能减低调用服务之间的耦合，又能成为调用之间的缓冲，确保消息积压不会冲垮被调用方，同时能 保证调用方的服务体验，继续干自己该干的活，不至于被后台性能拖慢。不过需要付出的代价是一致性的减弱，需要接受数据最终一致性；还有就是后台服务一般要 实现幂等性，因为消息发送出于性能的考虑一般会有重复（保证消息的被收到且仅收到一次对性能是很大的考验）；最后就是必须引入一个独立的 broker，如 果公司内部没有技术积累，对broker分布式管理也是一个很大的挑战。

![服务间通信](http://images2015.cnblogs.com/blog/15172/201612/15172-20161225120450964-1678545462.png)

#### 微服务架构的优点
  - 每个微服务都很小，这样能聚焦一个指定的业务功能或业务需求。
  - 微服务能够被小团队单独开发，这个小团队是2到5人的开发人员组成。
  - 微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的。
  -  微服务能使用不同的语言开发。
  -  微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如 Jenkins, bamboo 。
  -  一个团队的新成员能够更快投入生产。
  -  微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作才能体现价值。
  -  微服务允许你利用融合最新技术。
  -  微服务只是业务逻辑的代码，不会和 HTML, CSS 或其他界面组件混合。
  -  微服务能够即时被要求扩展。
  -  微服务能部署中低端配置的服务器上。
  -  易于和第三方集成。
  -  每个微服务都有自己的存储能力，可以有自己的数据库。也可以有统一数据库。

#### 微服务架构的缺点
  - 微服务架构可能带来过多的操作。
  - 需要 [DevOps](http://en.wikipedia.org/wiki/DevOps) 技巧.
  - 可能双倍的努力。
  - 分布式系统可能复杂难以管理。
  - 因为分布部署跟踪问题难。
  - 当服务数量增加，管理复杂性增加。

#### API 设计要素
 - Version
 - RequstID
 - Auth & Signature
 - RateLimit
 - Docs
 - ErrorCode & Message

![业务拆分](http://images2015.cnblogs.com/blog/15172/201612/15172-20161225120456292-1467180777.png)

#### 服务容错

当企业微服务化以后，服务之间会有错综复杂的依赖关系，例如，一个前端请求一般会依赖于多个后端服务，技术上称为1 &rarr; N扇出. 在实际生产环境中，服务往往不是百分百可靠，服务可能会出错或者产生延迟，如果一个应用不能对其依赖的故障进行容错和隔离，那么该应用本身就处在被拖垮的风险中。在一个高流量的网站中，某个单一后端一旦发生延迟，可能在数秒内导致所有应用资源(线程，队列等)被耗尽，造成所谓的雪崩效应( Cascading Failure)，严重时可致整个网站瘫痪。

![服务依赖](http://images2015.cnblogs.com/blog/15172/201612/15172-20161225120500370-1119380183.png)

![服务出错或延迟](http://images2015.cnblogs.com/blog/15172/201612/15172-20161225120501807-380954237.png)

#### 服务框架

- 服务注册、发现、负载均衡和健康检查，假定采用进程内LB方案，那么服务自注册一般统一做在服务器端框架中，健康检查逻辑由具体业务服务定制，框架层提供调用健康检查逻辑的机制，服务发现和负载均衡则集成在服务客户端框架中。

- 监控日志，框架一方面要记录重要的框架层日志、metrics和调用链数据，还要将日志、metrics等接口暴露出来，让业务层能根据需要记录业务日志数据。在运行环境中，所有日志数据一般集中落地到企业后台日志系统，做进一步分析和处理。

- REST/RPC和序列化，框架层要支持将业务逻辑以HTTP/REST或者RPC方式暴露出来，HTTP/REST是当前主流API暴露方式，在性能要求高的场合则可采用Binary/RPC方式。针对当前多样化的设备类型(浏览器、普通PC、无线设备等)，框架层要支持可定制的序列化机制，例如，对浏览器，框架支持输出Ajax友好的JSON消息格式，而对无线设备上的Native App，框架支持输出性能高的Binary消息格式。

- 配置，除了支持普通配置文件方式的配置，框架层还可集成动态运行时配置，能够在运行时针对不同环境动态调整服务的参数和配置。

- 限流和容错，框架集成限流容错组件，能够在运行时自动限流和容错，保护服务，如果进一步和动态配置相结合，还可以实现动态限流和熔断。

- 管理接口，框架集成管理接口，一方面可以在线查看框架和服务内部状态，同时还可以动态调整内部状态，对调试、监控和管理能提供快速反馈。Spring Boot微框架的Actuator模块就是一个强大的管理接口。

- 统一错误处理，对于框架层和服务的内部异常，如果框架层能够统一处理并记录日志，对服务监控和快速问题定位有很大帮助。

- 安全，安全和访问控制逻辑可以在框架层统一进行封装，可做成插件形式，具体业务服务根据需要加载相关安全插件。

- 文档自动生成，文档的书写和同步一直是一个痛点，框架层如果能支持文档的自动生成和同步，会给使用API的开发和测试人员带来极大便利。Swagger是一种流行Restful API的文档方案。

#### 微服务系统底座

###### 一个完整的微服务系统，它的底座最少要包含以下功能：

  - 日志和审计，主要是日志的汇总，分类和查询
  - 监控和告警，主要是监控每个服务的状态，必要时产生告警
  - 消息总线，轻量级的MQ或HTTP
  - 注册发现
  - 负载均衡
  - 部署和升级
  - 事件调度机制
  - 资源管理，如：底层的虚拟机，物理机和网络管理

###### 以下功能不是最小集的一部分，但也属于底座功能：

   - 认证和鉴权
   - 微服务统一代码框架，支持多种编程语言
   - 统一服务构建和打包
   - 统一服务测试
   - 微服务CI/CD流水线
   - 服务依赖关系管理
   - 统一问题跟踪调试框架，俗称调用链
   - 灰度发布
   - 蓝绿部署

##### 开发方式变革

随着持续交付概念推广以及Docker容器普及，微服务将这两种理念和技术结合起来，形成新的微服务+API + 平台的开发模式，提出了容器化微服务的持续交付概念。
###### Monolithic
![](https://images2015.cnblogs.com/blog/15172/201612/15172-20161225120503636-1994489776.png)

这种整体型架构要求产品队伍横跨产品管理 Dev开发 QA DBA 以及系统运营管理
###### Microservice
![](https://images2015.cnblogs.com/blog/15172/201612/15172-20161225120504495-784330631.png)

微服务促进了 DevOps 方式的重组，将一个大臃肿的整体产品开发队伍切分为根据不同微服务的划分的产品队伍，以及一个大的整体的平台队伍负责运营管理，两者之间通过API交互，做到了松耦合隔绝。

![](http://images2015.cnblogs.com/blog/15172/201612/15172-20161225120505026-803195363.png)

![](http://images2015.cnblogs.com/blog/15172/201612/15172-20161225120507401-1491275629.png)

由于Docker引入，不同的微服务可以使用不同的技术架构，比如Node.js Java Ruby Python等等，这些单个的服务都可以独立完成交付生命周期，如下:
![](https://images2015.cnblogs.com/blog/15172/201612/15172-20161225120509089-1131898325.png)



